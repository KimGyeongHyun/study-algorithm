# -*- coding: utf-8 -*-

# 기존 다익스트라 알고리즘에 힙 추가
# 기존 다익스트라 알고리즘 중 중간 노드를 구하는 get_smallest_node() 메소드는
# O(n) 의 시간복잡도를 가짐
# 힙 구조를 미리 만들어 놓고 최단 거리를 갱신할 때마다 push (시간복잡도 : O(log(n))),
# 최단 거리를 구할 때 pop (시간복잡도 : O(log(n))) 하면 시간복잡도를 O(log(n)) 으로 줄일 수 있다

# -구성
# 방향 그래프, 최단거리를 저장할 리스트, 거리와 노드를 저장할 힙
# 힙 -> (거리, 노드) 여러개
# 힙 구조이기 때문에 거리 오름차순 기준으로 데이터가 '어느정도' 배치된다 

# -작동 방식
# 힙에 (0, 시작 노드) push  
# 시작 노드 최단거리 0 설정
# (===== 힙 안에 데이터 없을 때까지 반복)
# ==================================================
# 힙을 pop 한다 
#   시작 노드 기준 최단 거리를 가진 중간 노드와 중간 노드까지의 거리를 추출하고 힙에서 제거한다
# 현재 최단거리 리스트와 비교했을 때 위에서 구한 중간 노드까지의 거리가 크다면
#   이미 현재 최단거리가 해당 거리보다 작은 값으로 갱신되었고
#   현재 최단거리는 최단거리 리스트가 갱신되면서 힙에 push 되었을 것이기 때문에 (29번 라인 참고)
#   위에서 pop 하면서 구한 정보는 필요없는 정보이므로 무시하고 다시 반복문 맨 위로 올라간다
# (----- 중간 노드에서 도착할 수 있는 노드 모두 탐색(반복))
# ---------------------------------------------------
# 도착 노드 기준 "시작 노드 -> 중간 노드" + "중간 노드 -> 도착 노드" < "현재 최단거리" 라면
# 해당 값으로 최단거리를 갱신하고
# 힙에 (최단거리, 중간 노드) 를 push 한다
# ---------------------------------------------------
# ===================================================

import heapq
import sys
input = sys.stdin.readline
INF = int(1e9)

# 노드 갯수, 간선 갯수
n, m = map(int, input().split())
# 시작 노드
start = int(input())
# key : 출발 노드, value : (도착 노드, 거리)
graph = [[] for i in range(n + 1)]
# 최단 거리 저장할 리스트
# key : 노드, value : 최단 길이
distance = [INF] * (n + 1)

# 간선 입력
for _ in range(m):
    # 출발 노드, 도착 노드, 거리
    a, b, c = map(int, input().split())
    graph[a].append((b, c))


def dijkstra(start):
    q = []  # 힙
    heapq.heappush(q, (0, start))
    distance[start] = 0

    while q:    # 큐가 빌 때까지 반복
        # pop 하면서 최단거리를 가지는 중간 노드와 해당 최단거리가 추출된다
        # dist : 거리, now : 중간 노드
        dist, now = heapq.heappop(q)
        
        # 이미 더 작은 거리로 갱신 되었다면 추출된 값은 무시한다
        if distance[now] < dist:
            continue

        # 중간 노드에서 도착할 수 있는 노드 순환
        for i in graph[now]:
            # dist : 현 시점 시작 노드 -> 중간 노드 최단 거리, i[1] : 중간 노드 -> 도착 노드 거리
            cost = dist + i[1]
            # i[0] : 도착 노드, distance[i[0]] : 현 시점 시작 노드 -> 도착 노드 최단 거리
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))     # 힙에 최단거리, 중간 노드 정보 push


dijkstra(start)

for i in range(1, n + 1):

    if distance[i] == INF:
        print("INFINITY")
    else:
        print(distance[i])

# input
# 6 11
# 1    
# 1 2 2
# 1 3 5
# 1 4 1
# 2 3 3
# 2 4 2
# 3 2 3
# 3 6 5
# 4 3 3
# 4 5 1
# 5 3 1
# 5 6 2

# output
# 0
# 2
# 3
# 1
# 2
# 4