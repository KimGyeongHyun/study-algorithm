dynamic programming (동적 계획법)
큰 문제를 작은 문제로 나누어 푸는 문제,
한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘

dp 를 사용하기 위한 조건
1. 최적 부분 구조 (Optimal Substructure)
    큰 문제를 작은 문제로 나눌 수 있고,
    작은 문제의 답을 모아 큰 문제 해결 가능
2. 중복되는 부분 문제 (Overlapping Subproblem)
    동일한 작은 문제를 반복적으로 해결해야 하는 경우

피보나치 수열의 경우 작은 수의 피보나치 수를 계산할 때 여러번 불림
하지만 해당 수를 메모이제이션하면 계산 없이 방문만 하면 된다 (Cache)

dp 구현 방법 2가지
1. Top down : 큰 문제를 작은 문제로 쪼개 해결, 재귀로 구현
    틀만 짜놓기 때문에 구현이 크게 어렵지 않지만
    간편한 만큼 논리 오류가 빈번하게 발생하기 때문에
    구상을 명확하게 해야 한다
    또한 오류가 하나라도 발생하면 틀을 모두 바꿔야 하기 때문에
    처음 구상한 틀이 잘 못 된 경우 수정이 번거롭다

    분할 정복과의 차이
    작은 문제들의 중복 유무

2. Bottom up : 작은 문제부터 차례대로 해결, 반복문으로 구현
    구현을 직접해야 하기 때문에 번거롭지만
    모든 케이스를 하나씩 따져가며 구상하기 때문에
    문제 풀이에 확실하고 디버깅에 유용하다

ex.11066
1. Top down : 재귀 함수로 파일 구성 최소시간 갱신
    같은 값을 여러번 부르지 않도록 메모이제이션 사용
    풀이가 간단하다
2. Bottom up : dp 를 작은 부분부터 직접 계산
    직접 메모이제이션을 구현한다

